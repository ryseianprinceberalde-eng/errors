{"ast":null,"code":"import BaseApiService from './baseApiService';\nimport axios from 'axios';\n\n/**\r\n * GIBS (Global Imagery Browse Services) monitoring-only service\r\n * Provides lightweight methods to check availability and retrieve tile URLs.\r\n */\nclass GIBSService extends BaseApiService {\n  constructor() {\n    super();\n    this.baseUrl = 'https://gibs.earthdata.nasa.gov';\n    this.wmtsBase = `${this.baseUrl}/wmts/epsg4326/best`;\n    // A common set of layers useful for monitoring (can be extended)\n    this.defaultLayers = ['MODIS_Terra_CorrectedReflectance_TrueColor', 'VIIRS_SNPP_Thermal_Anomalies_Day', 'MODIS_Terra_Aerosol'];\n  }\n\n  /**\r\n   * Fetch WMTS GetCapabilities XML to verify service availability\r\n   * @returns {Promise<string>} XML string\r\n   */\n  async getCapabilities() {\n    const url = `${this.wmtsBase}?SERVICE=WMTS&REQUEST=GetCapabilities`;\n    return this.get(url, {\n      timeout: 10000,\n      responseType: 'text'\n    });\n  }\n\n  /**\r\n   * Basic health check that attempts to fetch GetCapabilities and a sample tile\r\n   * @returns {Promise<object>} status summary\r\n   */\n  async healthCheck() {\n    const result = {\n      service: 'GIBS',\n      baseUrl: this.baseUrl,\n      capabilities: {\n        ok: false,\n        status: null\n      },\n      sampleTile: {\n        ok: false,\n        status: null,\n        url: null\n      },\n      timestamp: new Date().toISOString()\n    };\n    try {\n      const caps = await this.getCapabilities();\n      result.capabilities.ok = true;\n      result.capabilities.status = 'fetched';\n    } catch (err) {\n      result.capabilities.ok = false;\n      result.capabilities.status = err.message || 'error';\n    }\n\n    // Try a sample tile for a default layer at zoom 2 / tile 1,1 (epsg4326)/(tiles use tilematrix)\n    try {\n      const layer = this.defaultLayers[0];\n      const tileUrl = this.getTileUrl({\n        layer,\n        tileMatrix: 2,\n        tileRow: 1,\n        tileCol: 1\n      });\n      result.sampleTile.url = tileUrl;\n\n      // Ping the tile (HEAD request) to avoid downloading large images\n      const head = await axios.head(tileUrl, {\n        timeout: 8000\n      });\n      result.sampleTile.ok = head.status >= 200 && head.status < 300;\n      result.sampleTile.status = head.status;\n    } catch (err) {\n      result.sampleTile.ok = false;\n      result.sampleTile.status = err.message || 'error';\n    }\n    return result;\n  }\n\n  /**\r\n   * Construct a WMTS tile URL for a given layer and tile indices (EPSG:4326)\r\n   * @param {object} opts\r\n   * @param {string} opts.layer\r\n   * @param {number|string} opts.tileMatrix\r\n   * @param {number|string} opts.tileRow\r\n   * @param {number|string} opts.tileCol\r\n   * @param {string} [format='image/png']\r\n   * @returns {string} tile URL\r\n   */\n  getTileUrl({\n    layer,\n    tileMatrix,\n    tileRow,\n    tileCol,\n    format = 'image/png'\n  }) {\n    // Example WMTS url pattern: /wmts/epsg4326/best/{Layer}/default/{TileMatrix}/{TileRow}/{TileCol}.{format}\n    // Use URL-encoded layer name and format extension\n    const ext = format.includes('png') ? 'png' : format.includes('jpg') || format.includes('jpeg') ? 'jpg' : 'png';\n    const encodedLayer = encodeURIComponent(layer);\n    return `${this.wmtsBase}/${encodedLayer}/default/${tileMatrix}/${tileRow}/${tileCol}.${ext}`;\n  }\n\n  /**\r\n   * Ping a specific tile using HEAD to check availability\r\n   * @param {object} opts same as getTileUrl\r\n   * @returns {Promise<{ok:boolean,status:number|string,url:string}>}\r\n   */\n  async pingTile(opts) {\n    const url = this.getTileUrl(opts);\n    try {\n      const res = await axios.head(url, {\n        timeout: 8000\n      });\n      return {\n        ok: res.status >= 200 && res.status < 300,\n        status: res.status,\n        url\n      };\n    } catch (err) {\n      return {\n        ok: false,\n        status: err.message || 'error',\n        url\n      };\n    }\n  }\n}\nexport default new GIBSService();","map":{"version":3,"names":["BaseApiService","axios","GIBSService","constructor","baseUrl","wmtsBase","defaultLayers","getCapabilities","url","get","timeout","responseType","healthCheck","result","service","capabilities","ok","status","sampleTile","timestamp","Date","toISOString","caps","err","message","layer","tileUrl","getTileUrl","tileMatrix","tileRow","tileCol","head","format","ext","includes","encodedLayer","encodeURIComponent","pingTile","opts","res"],"sources":["C:/xampp/htdocs/errors/src/services/api/gibsService.js"],"sourcesContent":["import BaseApiService from './baseApiService';\r\nimport axios from 'axios';\r\n\r\n/**\r\n * GIBS (Global Imagery Browse Services) monitoring-only service\r\n * Provides lightweight methods to check availability and retrieve tile URLs.\r\n */\r\nclass GIBSService extends BaseApiService {\r\n  constructor() {\r\n    super();\r\n    this.baseUrl = 'https://gibs.earthdata.nasa.gov';\r\n    this.wmtsBase = `${this.baseUrl}/wmts/epsg4326/best`;\r\n    // A common set of layers useful for monitoring (can be extended)\r\n    this.defaultLayers = [\r\n      'MODIS_Terra_CorrectedReflectance_TrueColor',\r\n      'VIIRS_SNPP_Thermal_Anomalies_Day',\r\n      'MODIS_Terra_Aerosol'\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Fetch WMTS GetCapabilities XML to verify service availability\r\n   * @returns {Promise<string>} XML string\r\n   */\r\n  async getCapabilities() {\r\n    const url = `${this.wmtsBase}?SERVICE=WMTS&REQUEST=GetCapabilities`;\r\n    return this.get(url, { timeout: 10000, responseType: 'text' });\r\n  }\r\n\r\n  /**\r\n   * Basic health check that attempts to fetch GetCapabilities and a sample tile\r\n   * @returns {Promise<object>} status summary\r\n   */\r\n  async healthCheck() {\r\n    const result = {\r\n      service: 'GIBS',\r\n      baseUrl: this.baseUrl,\r\n      capabilities: { ok: false, status: null },\r\n      sampleTile: { ok: false, status: null, url: null },\r\n      timestamp: new Date().toISOString()\r\n    };\r\n\r\n    try {\r\n      const caps = await this.getCapabilities();\r\n      result.capabilities.ok = true;\r\n      result.capabilities.status = 'fetched';\r\n    } catch (err) {\r\n      result.capabilities.ok = false;\r\n      result.capabilities.status = err.message || 'error';\r\n    }\r\n\r\n    // Try a sample tile for a default layer at zoom 2 / tile 1,1 (epsg4326)/(tiles use tilematrix)\r\n    try {\r\n      const layer = this.defaultLayers[0];\r\n      const tileUrl = this.getTileUrl({ layer, tileMatrix: 2, tileRow: 1, tileCol: 1 });\r\n      result.sampleTile.url = tileUrl;\r\n\r\n      // Ping the tile (HEAD request) to avoid downloading large images\r\n      const head = await axios.head(tileUrl, { timeout: 8000 });\r\n      result.sampleTile.ok = head.status >= 200 && head.status < 300;\r\n      result.sampleTile.status = head.status;\r\n    } catch (err) {\r\n      result.sampleTile.ok = false;\r\n      result.sampleTile.status = err.message || 'error';\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Construct a WMTS tile URL for a given layer and tile indices (EPSG:4326)\r\n   * @param {object} opts\r\n   * @param {string} opts.layer\r\n   * @param {number|string} opts.tileMatrix\r\n   * @param {number|string} opts.tileRow\r\n   * @param {number|string} opts.tileCol\r\n   * @param {string} [format='image/png']\r\n   * @returns {string} tile URL\r\n   */\r\n  getTileUrl({ layer, tileMatrix, tileRow, tileCol, format = 'image/png' }) {\r\n    // Example WMTS url pattern: /wmts/epsg4326/best/{Layer}/default/{TileMatrix}/{TileRow}/{TileCol}.{format}\r\n    // Use URL-encoded layer name and format extension\r\n    const ext = format.includes('png') ? 'png' : format.includes('jpg') || format.includes('jpeg') ? 'jpg' : 'png';\r\n    const encodedLayer = encodeURIComponent(layer);\r\n    return `${this.wmtsBase}/${encodedLayer}/default/${tileMatrix}/${tileRow}/${tileCol}.${ext}`;\r\n  }\r\n\r\n  /**\r\n   * Ping a specific tile using HEAD to check availability\r\n   * @param {object} opts same as getTileUrl\r\n   * @returns {Promise<{ok:boolean,status:number|string,url:string}>}\r\n   */\r\n  async pingTile(opts) {\r\n    const url = this.getTileUrl(opts);\r\n    try {\r\n      const res = await axios.head(url, { timeout: 8000 });\r\n      return { ok: res.status >= 200 && res.status < 300, status: res.status, url };\r\n    } catch (err) {\r\n      return { ok: false, status: err.message || 'error', url };\r\n    }\r\n  }\r\n}\r\n\r\nexport default new GIBSService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}