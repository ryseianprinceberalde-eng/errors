{"ast":null,"code":"import BaseApiService from './baseApiService.js';\n\n/**\r\n * GIBS (Global Imagery Browse Services) Service\r\n * Handles satellite imagery and Earth observation data for weather analysis\r\n */\nclass GIBSService extends BaseApiService {\n  constructor() {\n    super();\n    this.baseUrl = 'https://gibs.earthdata.nasa.gov';\n    this.wmtsBase = `${this.baseUrl}/wmts/epsg4326/best`;\n\n    // Weather-specific layers for analysis with enhanced descriptions\n    this.weatherLayers = {\n      clouds: {\n        id: 'MODIS_Terra_Cloud_Top_Temp_Day',\n        title: 'Cloud Top Temperature (Day)',\n        format: 'image/jpeg',\n        matrix: 'EPSG4326_2km',\n        style: 'default',\n        time: 'default'\n      },\n      precipitation: {\n        id: 'IMERG_Precipitation_Rate',\n        title: 'IMERG Precipitation Rate',\n        format: 'image/png',\n        matrix: 'EPSG4326_2km',\n        style: 'default',\n        time: '2024-01-01/2025-12-31/P1D'\n      },\n      wind: {\n        id: 'AMSRU2_Sea_Surface_Wind_Speed_Day',\n        title: 'Wind Speed Over Oceans (Day)',\n        format: 'image/png',\n        matrix: 'EPSG4326_2km',\n        style: 'default',\n        time: 'default'\n      },\n      temperature: {\n        id: 'MODIS_Terra_Land_Surface_Temp_Day',\n        title: 'Land Surface Temperature (Day)',\n        format: 'image/jpeg',\n        matrix: 'EPSG4326_1km',\n        style: 'default',\n        time: 'default'\n      },\n      snow: {\n        id: 'MODIS_Terra_Snow_Cover',\n        title: 'Snow Cover',\n        format: 'image/png',\n        matrix: 'EPSG4326_250m',\n        style: 'default',\n        time: 'default'\n      },\n      trueColor: {\n        id: 'MODIS_Terra_CorrectedReflectance_TrueColor',\n        title: 'True Color (Day)',\n        format: 'image/jpeg',\n        matrix: 'EPSG4326_250m',\n        style: 'default',\n        time: 'default'\n      }\n    };\n\n    // Advanced monitoring layers for specialized analysis\n    this.monitoringLayers = {\n      fires: {\n        id: 'MODIS_Terra_Thermal_Anomalies_Day',\n        title: 'Thermal Anomalies/Fire (Day)',\n        format: 'image/png',\n        matrix: 'EPSG4326_1km'\n      },\n      aerosol: {\n        id: 'MODIS_Terra_Aerosol',\n        title: 'Aerosol Optical Depth',\n        format: 'image/png',\n        matrix: 'EPSG4326_2km'\n      },\n      waterVapor: {\n        id: 'MODIS_Terra_Water_Vapor',\n        title: 'Water Vapor',\n        format: 'image/png',\n        matrix: 'EPSG4326_2km'\n      },\n      seaIce: {\n        id: 'MODIS_Terra_Sea_Ice',\n        title: 'Sea Ice Extent',\n        format: 'image/png',\n        matrix: 'EPSG4326_1km'\n      }\n    };\n  }\n\n  /**\r\n   * Fetch WMTS GetCapabilities XML to verify service availability\r\n   * @returns {Promise<string>} XML string\r\n   */\n  async getCapabilities() {\n    const url = `${this.wmtsBase}?SERVICE=WMTS&REQUEST=GetCapabilities`;\n    return this.get(url, {\n      timeout: 10000,\n      responseType: 'text'\n    });\n  }\n\n  /**\r\n   * Basic health check that attempts to fetch GetCapabilities and a sample tile\r\n   * @returns {Promise<object>} status summary\r\n   */\n  async healthCheck() {\n    const result = {\n      service: 'GIBS',\n      baseUrl: this.baseUrl,\n      capabilities: {\n        ok: false,\n        status: null\n      },\n      sampleTile: {\n        ok: false,\n        status: null,\n        url: null\n      },\n      timestamp: new Date().toISOString()\n    };\n    try {\n      const caps = await this.getCapabilities();\n      result.capabilities.ok = true;\n      result.capabilities.status = 'fetched';\n\n      // Check a sample tile\n      const date = new Date().toISOString().split('T')[0];\n      const tileUrl = this.buildTileUrl(this.weatherLayers.trueColor, date, 2, 1, 1);\n      result.sampleTile.url = tileUrl;\n      const response = await fetch(tileUrl, {\n        method: 'HEAD',\n        signal: AbortSignal.timeout(8000)\n      });\n      result.sampleTile.ok = response.ok;\n      result.sampleTile.status = response.status;\n    } catch (err) {\n      if (!result.capabilities.ok) {\n        result.capabilities.status = err.message || 'error';\n      }\n      result.sampleTile.ok = false;\n      result.sampleTile.status = err.message || 'error';\n    }\n    return result;\n  }\n\n  /**\r\n   * Get weather satellite data for a specific location\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {string} date - ISO date string (YYYY-MM-DD)\r\n   * @returns {Promise<Object>} Weather satellite data\r\n   */\n  async getWeatherSatelliteData(lat, lon, date) {\n    const weatherData = {};\n    for (const [key, layer] of Object.entries(this.weatherLayers)) {\n      try {\n        const tileInfo = await this.getTileForLocation(lat, lon, layer, date);\n        weatherData[key] = {\n          tileUrl: tileInfo.url,\n          resolution: tileInfo.resolution,\n          time: date,\n          available: true\n        };\n      } catch (error) {\n        console.error(`Error fetching ${key} data:`, error);\n        weatherData[key] = {\n          available: false,\n          error: error.message\n        };\n      }\n    }\n    return {\n      location: {\n        lat,\n        lon\n      },\n      timestamp: new Date().toISOString(),\n      layers: weatherData\n    };\n  }\n\n  /**\r\n   * Get tile information for a specific location\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {string} layer - GIBS layer identifier\r\n   * @param {string} date - ISO date string\r\n   * @returns {Promise<Object>} Tile information\r\n   */\n  async getTileForLocation(lat, lon, layer, date) {\n    const zoom = this.calculateZoomLevel(lat);\n    const [x, y] = this.latLonToTile(lat, lon, zoom);\n    const url = this.buildTileUrl(layer, date, zoom, x, y);\n    const resolution = this.getResolutionForZoom(zoom);\n    return {\n      url,\n      zoom,\n      x,\n      y,\n      resolution,\n      attribution: 'NASA GIBS'\n    };\n  }\n\n  /**\r\n   * Calculate appropriate zoom level based on latitude\r\n   * @param {number} lat - Latitude\r\n   * @returns {number} Zoom level\r\n   */\n  calculateZoomLevel(lat) {\n    const absLat = Math.abs(lat);\n    if (absLat > 80) return 3;\n    if (absLat > 70) return 4;\n    if (absLat > 60) return 5;\n    return 6;\n  }\n\n  /**\r\n   * Convert lat/lon to tile coordinates\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {number} zoom - Zoom level\r\n   * @returns {Array<number>} [x, y] tile coordinates\r\n   */\n  latLonToTile(lat, lon, zoom) {\n    const n = Math.pow(2, zoom);\n    const x = Math.floor((lon + 180) / 360 * n);\n    const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);\n    return [x, y];\n  }\n\n  /**\r\n   * Build URL for a specific tile\r\n   * @param {string} layer - GIBS layer identifier\r\n   * @param {string} date - ISO date string\r\n   * @param {number} zoom - Zoom level\r\n   * @param {number} x - Tile x coordinate\r\n   * @param {number} y - Tile y coordinate\r\n   * @returns {string} Tile URL\r\n   */\n  buildTileUrl(layer, date, zoom, x, y) {\n    return `${this.wmtsBase}/${layer}/default/${date}/epsg4326/${zoom}/${y}/${x}.jpg`;\n  }\n\n  /**\r\n   * Get resolution in meters for zoom level\r\n   * @param {number} zoom - Zoom level\r\n   * @returns {number} Resolution in meters\r\n   */\n  getResolutionForZoom(zoom) {\n    const baseResolution = 156543.03392; // meters/pixel at zoom 0\n    return baseResolution / Math.pow(2, zoom);\n  }\n\n  /**\r\n   * Construct a WMTS tile URL for a given layer and tile indices (EPSG:4326)\r\n   * @param {object} opts\r\n   * @param {string} opts.layer\r\n   * @param {number|string} opts.tileMatrix\r\n   * @param {number|string} opts.tileRow\r\n   * @param {number|string} opts.tileCol\r\n   * @param {string} [format='image/png']\r\n   * @returns {string} tile URL\r\n   */\n  getTileUrl({\n    layer,\n    tileMatrix,\n    tileRow,\n    tileCol,\n    format = 'image/png',\n    time\n  }) {\n    // Example WMTS url pattern: /wmts/epsg4326/best/{Layer}/default/{Time}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.{format}\n    const ext = format.includes('png') ? 'png' : format.includes('jpg') || format.includes('jpeg') ? 'jpg' : 'png';\n    const encodedLayer = encodeURIComponent(layer);\n\n    // Choose appropriate tile matrix set based on layer and zoom\n    let tileMatrixSet = 'EPSG4326_250m'; // Default high resolution\n    if (layer.includes('IMERG') || layer.includes('MERRA2') || layer.includes('Aerosol')) {\n      tileMatrixSet = 'EPSG4326_2km';\n    } else if (layer.includes('Cloud_Top_Temp') || layer.includes('Water_Vapor')) {\n      tileMatrixSet = 'EPSG4326_1km';\n    }\n\n    // Format time string - default to today if not provided\n    const timeStr = time || new Date().toISOString().split('T')[0];\n    return `${this.wmtsBase}/${encodedLayer}/default/${timeStr}/${tileMatrixSet}/${tileMatrix}/${tileRow}/${tileCol}.${ext}`;\n  }\n\n  /**\r\n   * Ping a specific tile using HEAD to check availability\r\n   * @param {object} opts same as getTileUrl\r\n   * @returns {Promise<{ok:boolean,status:number|string,url:string}>}\r\n   */\n  async pingTile(opts) {\n    const url = this.getTileUrl(opts);\n    try {\n      const response = await fetch(url, {\n        method: 'HEAD',\n        signal: AbortSignal.timeout(8000)\n      });\n      return {\n        ok: response.ok,\n        status: response.status,\n        url\n      };\n    } catch (err) {\n      return {\n        ok: false,\n        status: err.message || 'error',\n        url\n      };\n    }\n  }\n}\nexport default GIBSService;","map":{"version":3,"names":["BaseApiService","GIBSService","constructor","baseUrl","wmtsBase","weatherLayers","clouds","id","title","format","matrix","style","time","precipitation","wind","temperature","snow","trueColor","monitoringLayers","fires","aerosol","waterVapor","seaIce","getCapabilities","url","get","timeout","responseType","healthCheck","result","service","capabilities","ok","status","sampleTile","timestamp","Date","toISOString","caps","date","split","tileUrl","buildTileUrl","response","fetch","method","signal","AbortSignal","err","message","getWeatherSatelliteData","lat","lon","weatherData","key","layer","Object","entries","tileInfo","getTileForLocation","resolution","available","error","console","location","layers","zoom","calculateZoomLevel","x","y","latLonToTile","getResolutionForZoom","attribution","absLat","Math","abs","n","pow","floor","log","tan","PI","cos","baseResolution","getTileUrl","tileMatrix","tileRow","tileCol","ext","includes","encodedLayer","encodeURIComponent","tileMatrixSet","timeStr","pingTile","opts"],"sources":["C:/xampp/htdocs/errors/src/services/api/gibsService.js"],"sourcesContent":["import BaseApiService from './baseApiService.js';\r\n\r\n/**\r\n * GIBS (Global Imagery Browse Services) Service\r\n * Handles satellite imagery and Earth observation data for weather analysis\r\n */\r\nclass GIBSService extends BaseApiService {\r\n  constructor() {\r\n    super();\r\n    this.baseUrl = 'https://gibs.earthdata.nasa.gov';\r\n    this.wmtsBase = `${this.baseUrl}/wmts/epsg4326/best`;\r\n    \r\n    // Weather-specific layers for analysis with enhanced descriptions\r\n    this.weatherLayers = {\r\n      clouds: {\r\n        id: 'MODIS_Terra_Cloud_Top_Temp_Day',\r\n        title: 'Cloud Top Temperature (Day)',\r\n        format: 'image/jpeg',\r\n        matrix: 'EPSG4326_2km',\r\n        style: 'default',\r\n        time: 'default'\r\n      },\r\n      precipitation: {\r\n        id: 'IMERG_Precipitation_Rate',\r\n        title: 'IMERG Precipitation Rate',\r\n        format: 'image/png',\r\n        matrix: 'EPSG4326_2km',\r\n        style: 'default',\r\n        time: '2024-01-01/2025-12-31/P1D'\r\n      },\r\n      wind: {\r\n        id: 'AMSRU2_Sea_Surface_Wind_Speed_Day',\r\n        title: 'Wind Speed Over Oceans (Day)',\r\n        format: 'image/png',\r\n        matrix: 'EPSG4326_2km',\r\n        style: 'default',\r\n        time: 'default'\r\n      },\r\n      temperature: {\r\n        id: 'MODIS_Terra_Land_Surface_Temp_Day',\r\n        title: 'Land Surface Temperature (Day)',\r\n        format: 'image/jpeg',\r\n        matrix: 'EPSG4326_1km',\r\n        style: 'default',\r\n        time: 'default'\r\n      },\r\n      snow: {\r\n        id: 'MODIS_Terra_Snow_Cover',\r\n        title: 'Snow Cover',\r\n        format: 'image/png',\r\n        matrix: 'EPSG4326_250m',\r\n        style: 'default',\r\n        time: 'default'\r\n      },\r\n      trueColor: {\r\n        id: 'MODIS_Terra_CorrectedReflectance_TrueColor',\r\n        title: 'True Color (Day)',\r\n        format: 'image/jpeg',\r\n        matrix: 'EPSG4326_250m',\r\n        style: 'default',\r\n        time: 'default'\r\n      }\r\n    };\r\n\r\n    // Advanced monitoring layers for specialized analysis\r\n    this.monitoringLayers = {\r\n      fires: {\r\n        id: 'MODIS_Terra_Thermal_Anomalies_Day',\r\n        title: 'Thermal Anomalies/Fire (Day)',\r\n        format: 'image/png',\r\n        matrix: 'EPSG4326_1km'\r\n      },\r\n      aerosol: {\r\n        id: 'MODIS_Terra_Aerosol',\r\n        title: 'Aerosol Optical Depth',\r\n        format: 'image/png',\r\n        matrix: 'EPSG4326_2km'\r\n      },\r\n      waterVapor: {\r\n        id: 'MODIS_Terra_Water_Vapor',\r\n        title: 'Water Vapor',\r\n        format: 'image/png',\r\n        matrix: 'EPSG4326_2km'\r\n      },\r\n      seaIce: {\r\n        id: 'MODIS_Terra_Sea_Ice',\r\n        title: 'Sea Ice Extent',\r\n        format: 'image/png',\r\n        matrix: 'EPSG4326_1km'\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Fetch WMTS GetCapabilities XML to verify service availability\r\n   * @returns {Promise<string>} XML string\r\n   */\r\n  async getCapabilities() {\r\n    const url = `${this.wmtsBase}?SERVICE=WMTS&REQUEST=GetCapabilities`;\r\n    return this.get(url, { timeout: 10000, responseType: 'text' });\r\n  }\r\n\r\n  /**\r\n   * Basic health check that attempts to fetch GetCapabilities and a sample tile\r\n   * @returns {Promise<object>} status summary\r\n   */\r\n  async healthCheck() {\r\n    const result = {\r\n      service: 'GIBS',\r\n      baseUrl: this.baseUrl,\r\n      capabilities: { ok: false, status: null },\r\n      sampleTile: { ok: false, status: null, url: null },\r\n      timestamp: new Date().toISOString()\r\n    };\r\n\r\n    try {\r\n      const caps = await this.getCapabilities();\r\n      result.capabilities.ok = true;\r\n      result.capabilities.status = 'fetched';\r\n\r\n      // Check a sample tile\r\n      const date = new Date().toISOString().split('T')[0];\r\n      const tileUrl = this.buildTileUrl(this.weatherLayers.trueColor, date, 2, 1, 1);\r\n      result.sampleTile.url = tileUrl;\r\n\r\n      const response = await fetch(tileUrl, { \r\n        method: 'HEAD', \r\n        signal: AbortSignal.timeout(8000) \r\n      });\r\n      result.sampleTile.ok = response.ok;\r\n      result.sampleTile.status = response.status;\r\n    } catch (err) {\r\n      if (!result.capabilities.ok) {\r\n        result.capabilities.status = err.message || 'error';\r\n      }\r\n      result.sampleTile.ok = false;\r\n      result.sampleTile.status = err.message || 'error';\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get weather satellite data for a specific location\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {string} date - ISO date string (YYYY-MM-DD)\r\n   * @returns {Promise<Object>} Weather satellite data\r\n   */\r\n  async getWeatherSatelliteData(lat, lon, date) {\r\n    const weatherData = {};\r\n    \r\n    for (const [key, layer] of Object.entries(this.weatherLayers)) {\r\n      try {\r\n        const tileInfo = await this.getTileForLocation(lat, lon, layer, date);\r\n        weatherData[key] = {\r\n          tileUrl: tileInfo.url,\r\n          resolution: tileInfo.resolution,\r\n          time: date,\r\n          available: true\r\n        };\r\n      } catch (error) {\r\n        console.error(`Error fetching ${key} data:`, error);\r\n        weatherData[key] = { available: false, error: error.message };\r\n      }\r\n    }\r\n\r\n    return {\r\n      location: { lat, lon },\r\n      timestamp: new Date().toISOString(),\r\n      layers: weatherData\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get tile information for a specific location\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {string} layer - GIBS layer identifier\r\n   * @param {string} date - ISO date string\r\n   * @returns {Promise<Object>} Tile information\r\n   */\r\n  async getTileForLocation(lat, lon, layer, date) {\r\n    const zoom = this.calculateZoomLevel(lat);\r\n    const [x, y] = this.latLonToTile(lat, lon, zoom);\r\n    \r\n    const url = this.buildTileUrl(layer, date, zoom, x, y);\r\n    const resolution = this.getResolutionForZoom(zoom);\r\n\r\n    return {\r\n      url,\r\n      zoom,\r\n      x,\r\n      y,\r\n      resolution,\r\n      attribution: 'NASA GIBS'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate appropriate zoom level based on latitude\r\n   * @param {number} lat - Latitude\r\n   * @returns {number} Zoom level\r\n   */\r\n  calculateZoomLevel(lat) {\r\n    const absLat = Math.abs(lat);\r\n    if (absLat > 80) return 3;\r\n    if (absLat > 70) return 4;\r\n    if (absLat > 60) return 5;\r\n    return 6;\r\n  }\r\n\r\n  /**\r\n   * Convert lat/lon to tile coordinates\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {number} zoom - Zoom level\r\n   * @returns {Array<number>} [x, y] tile coordinates\r\n   */\r\n  latLonToTile(lat, lon, zoom) {\r\n    const n = Math.pow(2, zoom);\r\n    const x = Math.floor((lon + 180) / 360 * n);\r\n    const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + \r\n      1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);\r\n    return [x, y];\r\n  }\r\n\r\n  /**\r\n   * Build URL for a specific tile\r\n   * @param {string} layer - GIBS layer identifier\r\n   * @param {string} date - ISO date string\r\n   * @param {number} zoom - Zoom level\r\n   * @param {number} x - Tile x coordinate\r\n   * @param {number} y - Tile y coordinate\r\n   * @returns {string} Tile URL\r\n   */\r\n  buildTileUrl(layer, date, zoom, x, y) {\r\n    return `${this.wmtsBase}/${layer}/default/${date}/epsg4326/${zoom}/${y}/${x}.jpg`;\r\n  }\r\n\r\n  /**\r\n   * Get resolution in meters for zoom level\r\n   * @param {number} zoom - Zoom level\r\n   * @returns {number} Resolution in meters\r\n   */\r\n  getResolutionForZoom(zoom) {\r\n    const baseResolution = 156543.03392; // meters/pixel at zoom 0\r\n    return baseResolution / Math.pow(2, zoom);\r\n  }\r\n\r\n  /**\r\n   * Construct a WMTS tile URL for a given layer and tile indices (EPSG:4326)\r\n   * @param {object} opts\r\n   * @param {string} opts.layer\r\n   * @param {number|string} opts.tileMatrix\r\n   * @param {number|string} opts.tileRow\r\n   * @param {number|string} opts.tileCol\r\n   * @param {string} [format='image/png']\r\n   * @returns {string} tile URL\r\n   */\r\n  getTileUrl({ layer, tileMatrix, tileRow, tileCol, format = 'image/png', time }) {\r\n    // Example WMTS url pattern: /wmts/epsg4326/best/{Layer}/default/{Time}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.{format}\r\n    const ext = format.includes('png') ? 'png' : format.includes('jpg') || format.includes('jpeg') ? 'jpg' : 'png';\r\n    const encodedLayer = encodeURIComponent(layer);\r\n    \r\n    // Choose appropriate tile matrix set based on layer and zoom\r\n    let tileMatrixSet = 'EPSG4326_250m'; // Default high resolution\r\n    if (layer.includes('IMERG') || layer.includes('MERRA2') || layer.includes('Aerosol')) {\r\n      tileMatrixSet = 'EPSG4326_2km';\r\n    } else if (layer.includes('Cloud_Top_Temp') || layer.includes('Water_Vapor')) {\r\n      tileMatrixSet = 'EPSG4326_1km';\r\n    }\r\n\r\n    // Format time string - default to today if not provided\r\n    const timeStr = time || new Date().toISOString().split('T')[0];\r\n\r\n    return `${this.wmtsBase}/${encodedLayer}/default/${timeStr}/${tileMatrixSet}/${tileMatrix}/${tileRow}/${tileCol}.${ext}`;\r\n  }\r\n\r\n  /**\r\n   * Ping a specific tile using HEAD to check availability\r\n   * @param {object} opts same as getTileUrl\r\n   * @returns {Promise<{ok:boolean,status:number|string,url:string}>}\r\n   */\r\n  async pingTile(opts) {\r\n    const url = this.getTileUrl(opts);\r\n    try {\r\n      const response = await fetch(url, { \r\n        method: 'HEAD',\r\n        signal: AbortSignal.timeout(8000)\r\n      });\r\n      return { \r\n        ok: response.ok, \r\n        status: response.status, \r\n        url \r\n      };\r\n    } catch (err) {\r\n      return { \r\n        ok: false, \r\n        status: err.message || 'error', \r\n        url \r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nexport default GIBSService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}