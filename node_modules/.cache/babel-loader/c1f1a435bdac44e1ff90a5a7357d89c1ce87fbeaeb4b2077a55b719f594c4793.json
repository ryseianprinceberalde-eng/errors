{"ast":null,"code":"import BaseApiService from './baseApiService';\n\n/**\r\n * GIBS (Global Imagery Browse Services) Service\r\n * Handles satellite imagery and Earth observation data for weather analysis\r\n */\nclass GIBSService extends BaseApiService {\n  constructor() {\n    super();\n    this.baseUrl = 'https://gibs.earthdata.nasa.gov';\n    this.wmtsBase = `${this.baseUrl}/wmts/epsg4326/best`;\n\n    // Weather-specific layers for analysis\n    this.weatherLayers = {\n      clouds: 'MODIS_Terra_Cloud_Top_Temp_Day',\n      precipitation: 'IMERG_Precipitation_Rate',\n      wind: 'AMSRU2_Sea_Surface_Wind_Speed_Day',\n      temperature: 'MODIS_Terra_Land_Surface_Temp_Day',\n      trueColor: 'MODIS_Terra_CorrectedReflectance_TrueColor'\n    };\n\n    // Additional layers for advanced monitoring\n    this.monitoringLayers = ['VIIRS_SNPP_Thermal_Anomalies_Day', 'MODIS_Terra_Aerosol', 'MODIS_Terra_Water_Vapor'];\n  }\n\n  /**\r\n   * Fetch WMTS GetCapabilities XML to verify service availability\r\n   * @returns {Promise<string>} XML string\r\n   */\n  async getCapabilities() {\n    const url = `${this.wmtsBase}?SERVICE=WMTS&REQUEST=GetCapabilities`;\n    return this.get(url, {\n      timeout: 10000,\n      responseType: 'text'\n    });\n  }\n\n  /**\r\n   * Basic health check that attempts to fetch GetCapabilities and a sample tile\r\n   * @returns {Promise<object>} status summary\r\n   */\n  async healthCheck() {\n    const result = {\n      service: 'GIBS',\n      baseUrl: this.baseUrl,\n      capabilities: {\n        ok: false,\n        status: null\n      },\n      sampleTile: {\n        ok: false,\n        status: null,\n        url: null\n      },\n      timestamp: new Date().toISOString()\n    };\n    try {\n      const caps = await this.getCapabilities();\n      result.capabilities.ok = true;\n      result.capabilities.status = 'fetched';\n\n      // Check a sample tile\n      const date = new Date().toISOString().split('T')[0];\n      const tileUrl = this.buildTileUrl(this.weatherLayers.trueColor, date, 2, 1, 1);\n      result.sampleTile.url = tileUrl;\n      const response = await fetch(tileUrl, {\n        method: 'HEAD',\n        signal: AbortSignal.timeout(8000)\n      });\n      result.sampleTile.ok = response.ok;\n      result.sampleTile.status = response.status;\n    } catch (err) {\n      if (!result.capabilities.ok) {\n        result.capabilities.status = err.message || 'error';\n      }\n      result.sampleTile.ok = false;\n      result.sampleTile.status = err.message || 'error';\n    }\n    return result;\n  }\n\n  /**\r\n   * Get weather satellite data for a specific location\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {string} date - ISO date string (YYYY-MM-DD)\r\n   * @returns {Promise<Object>} Weather satellite data\r\n   */\n  async getWeatherSatelliteData(lat, lon, date) {\n    const weatherData = {};\n    for (const [key, layer] of Object.entries(this.weatherLayers)) {\n      try {\n        const tileInfo = await this.getTileForLocation(lat, lon, layer, date);\n        weatherData[key] = {\n          tileUrl: tileInfo.url,\n          resolution: tileInfo.resolution,\n          time: date,\n          available: true\n        };\n      } catch (error) {\n        console.error(`Error fetching ${key} data:`, error);\n        weatherData[key] = {\n          available: false,\n          error: error.message\n        };\n      }\n    }\n    return {\n      location: {\n        lat,\n        lon\n      },\n      timestamp: new Date().toISOString(),\n      layers: weatherData\n    };\n  }\n\n  /**\r\n   * Get tile information for a specific location\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {string} layer - GIBS layer identifier\r\n   * @param {string} date - ISO date string\r\n   * @returns {Promise<Object>} Tile information\r\n   */\n  async getTileForLocation(lat, lon, layer, date) {\n    const zoom = this.calculateZoomLevel(lat);\n    const [x, y] = this.latLonToTile(lat, lon, zoom);\n    const url = this.buildTileUrl(layer, date, zoom, x, y);\n    const resolution = this.getResolutionForZoom(zoom);\n    return {\n      url,\n      zoom,\n      x,\n      y,\n      resolution,\n      attribution: 'NASA GIBS'\n    };\n  }\n\n  /**\r\n   * Calculate appropriate zoom level based on latitude\r\n   * @param {number} lat - Latitude\r\n   * @returns {number} Zoom level\r\n   */\n  calculateZoomLevel(lat) {\n    const absLat = Math.abs(lat);\n    if (absLat > 80) return 3;\n    if (absLat > 70) return 4;\n    if (absLat > 60) return 5;\n    return 6;\n  }\n\n  /**\r\n   * Convert lat/lon to tile coordinates\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {number} zoom - Zoom level\r\n   * @returns {Array<number>} [x, y] tile coordinates\r\n   */\n  latLonToTile(lat, lon, zoom) {\n    const n = Math.pow(2, zoom);\n    const x = Math.floor((lon + 180) / 360 * n);\n    const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);\n    return [x, y];\n  }\n\n  /**\r\n   * Build URL for a specific tile\r\n   * @param {string} layer - GIBS layer identifier\r\n   * @param {string} date - ISO date string\r\n   * @param {number} zoom - Zoom level\r\n   * @param {number} x - Tile x coordinate\r\n   * @param {number} y - Tile y coordinate\r\n   * @returns {string} Tile URL\r\n   */\n  buildTileUrl(layer, date, zoom, x, y) {\n    return `${this.wmtsBase}/${layer}/default/${date}/epsg4326/${zoom}/${y}/${x}.jpg`;\n  }\n\n  /**\r\n   * Get resolution in meters for zoom level\r\n   * @param {number} zoom - Zoom level\r\n   * @returns {number} Resolution in meters\r\n   */\n  getResolutionForZoom(zoom) {\n    const baseResolution = 156543.03392; // meters/pixel at zoom 0\n    return baseResolution / Math.pow(2, zoom);\n  }\n\n  /**\r\n   * Construct a WMTS tile URL for a given layer and tile indices (EPSG:4326)\r\n   * @param {object} opts\r\n   * @param {string} opts.layer\r\n   * @param {number|string} opts.tileMatrix\r\n   * @param {number|string} opts.tileRow\r\n   * @param {number|string} opts.tileCol\r\n   * @param {string} [format='image/png']\r\n   * @returns {string} tile URL\r\n   */\n  getTileUrl({\n    layer,\n    tileMatrix,\n    tileRow,\n    tileCol,\n    format = 'image/png'\n  }) {\n    // Example WMTS url pattern: /wmts/epsg4326/best/{Layer}/default/{TileMatrix}/{TileRow}/{TileCol}.{format}\n    // Use URL-encoded layer name and format extension\n    const ext = format.includes('png') ? 'png' : format.includes('jpg') || format.includes('jpeg') ? 'jpg' : 'png';\n    const encodedLayer = encodeURIComponent(layer);\n    return `${this.wmtsBase}/${encodedLayer}/default/${tileMatrix}/${tileRow}/${tileCol}.${ext}`;\n  }\n\n  /**\r\n   * Ping a specific tile using HEAD to check availability\r\n   * @param {object} opts same as getTileUrl\r\n   * @returns {Promise<{ok:boolean,status:number|string,url:string}>}\r\n   */\n  async pingTile(opts) {\n    const url = this.getTileUrl(opts);\n    try {\n      const response = await fetch(url, {\n        method: 'HEAD',\n        signal: AbortSignal.timeout(8000)\n      });\n      return {\n        ok: response.ok,\n        status: response.status,\n        url\n      };\n    } catch (err) {\n      return {\n        ok: false,\n        status: err.message || 'error',\n        url\n      };\n    }\n  }\n}\nexport default new GIBSService();","map":{"version":3,"names":["BaseApiService","GIBSService","constructor","baseUrl","wmtsBase","weatherLayers","clouds","precipitation","wind","temperature","trueColor","monitoringLayers","getCapabilities","url","get","timeout","responseType","healthCheck","result","service","capabilities","ok","status","sampleTile","timestamp","Date","toISOString","caps","date","split","tileUrl","buildTileUrl","response","fetch","method","signal","AbortSignal","err","message","getWeatherSatelliteData","lat","lon","weatherData","key","layer","Object","entries","tileInfo","getTileForLocation","resolution","time","available","error","console","location","layers","zoom","calculateZoomLevel","x","y","latLonToTile","getResolutionForZoom","attribution","absLat","Math","abs","n","pow","floor","log","tan","PI","cos","baseResolution","getTileUrl","tileMatrix","tileRow","tileCol","format","ext","includes","encodedLayer","encodeURIComponent","pingTile","opts"],"sources":["C:/xampp/htdocs/errors/src/services/api/gibsService.js"],"sourcesContent":["import BaseApiService from './baseApiService';\r\n\r\n/**\r\n * GIBS (Global Imagery Browse Services) Service\r\n * Handles satellite imagery and Earth observation data for weather analysis\r\n */\r\nclass GIBSService extends BaseApiService {\r\n  constructor() {\r\n    super();\r\n    this.baseUrl = 'https://gibs.earthdata.nasa.gov';\r\n    this.wmtsBase = `${this.baseUrl}/wmts/epsg4326/best`;\r\n    \r\n    // Weather-specific layers for analysis\r\n    this.weatherLayers = {\r\n      clouds: 'MODIS_Terra_Cloud_Top_Temp_Day',\r\n      precipitation: 'IMERG_Precipitation_Rate',\r\n      wind: 'AMSRU2_Sea_Surface_Wind_Speed_Day',\r\n      temperature: 'MODIS_Terra_Land_Surface_Temp_Day',\r\n      trueColor: 'MODIS_Terra_CorrectedReflectance_TrueColor'\r\n    };\r\n\r\n    // Additional layers for advanced monitoring\r\n    this.monitoringLayers = [\r\n      'VIIRS_SNPP_Thermal_Anomalies_Day',\r\n      'MODIS_Terra_Aerosol',\r\n      'MODIS_Terra_Water_Vapor'\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Fetch WMTS GetCapabilities XML to verify service availability\r\n   * @returns {Promise<string>} XML string\r\n   */\r\n  async getCapabilities() {\r\n    const url = `${this.wmtsBase}?SERVICE=WMTS&REQUEST=GetCapabilities`;\r\n    return this.get(url, { timeout: 10000, responseType: 'text' });\r\n  }\r\n\r\n  /**\r\n   * Basic health check that attempts to fetch GetCapabilities and a sample tile\r\n   * @returns {Promise<object>} status summary\r\n   */\r\n  async healthCheck() {\r\n    const result = {\r\n      service: 'GIBS',\r\n      baseUrl: this.baseUrl,\r\n      capabilities: { ok: false, status: null },\r\n      sampleTile: { ok: false, status: null, url: null },\r\n      timestamp: new Date().toISOString()\r\n    };\r\n\r\n    try {\r\n      const caps = await this.getCapabilities();\r\n      result.capabilities.ok = true;\r\n      result.capabilities.status = 'fetched';\r\n\r\n      // Check a sample tile\r\n      const date = new Date().toISOString().split('T')[0];\r\n      const tileUrl = this.buildTileUrl(this.weatherLayers.trueColor, date, 2, 1, 1);\r\n      result.sampleTile.url = tileUrl;\r\n\r\n      const response = await fetch(tileUrl, { \r\n        method: 'HEAD', \r\n        signal: AbortSignal.timeout(8000) \r\n      });\r\n      result.sampleTile.ok = response.ok;\r\n      result.sampleTile.status = response.status;\r\n    } catch (err) {\r\n      if (!result.capabilities.ok) {\r\n        result.capabilities.status = err.message || 'error';\r\n      }\r\n      result.sampleTile.ok = false;\r\n      result.sampleTile.status = err.message || 'error';\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get weather satellite data for a specific location\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {string} date - ISO date string (YYYY-MM-DD)\r\n   * @returns {Promise<Object>} Weather satellite data\r\n   */\r\n  async getWeatherSatelliteData(lat, lon, date) {\r\n    const weatherData = {};\r\n    \r\n    for (const [key, layer] of Object.entries(this.weatherLayers)) {\r\n      try {\r\n        const tileInfo = await this.getTileForLocation(lat, lon, layer, date);\r\n        weatherData[key] = {\r\n          tileUrl: tileInfo.url,\r\n          resolution: tileInfo.resolution,\r\n          time: date,\r\n          available: true\r\n        };\r\n      } catch (error) {\r\n        console.error(`Error fetching ${key} data:`, error);\r\n        weatherData[key] = { available: false, error: error.message };\r\n      }\r\n    }\r\n\r\n    return {\r\n      location: { lat, lon },\r\n      timestamp: new Date().toISOString(),\r\n      layers: weatherData\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get tile information for a specific location\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {string} layer - GIBS layer identifier\r\n   * @param {string} date - ISO date string\r\n   * @returns {Promise<Object>} Tile information\r\n   */\r\n  async getTileForLocation(lat, lon, layer, date) {\r\n    const zoom = this.calculateZoomLevel(lat);\r\n    const [x, y] = this.latLonToTile(lat, lon, zoom);\r\n    \r\n    const url = this.buildTileUrl(layer, date, zoom, x, y);\r\n    const resolution = this.getResolutionForZoom(zoom);\r\n\r\n    return {\r\n      url,\r\n      zoom,\r\n      x,\r\n      y,\r\n      resolution,\r\n      attribution: 'NASA GIBS'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate appropriate zoom level based on latitude\r\n   * @param {number} lat - Latitude\r\n   * @returns {number} Zoom level\r\n   */\r\n  calculateZoomLevel(lat) {\r\n    const absLat = Math.abs(lat);\r\n    if (absLat > 80) return 3;\r\n    if (absLat > 70) return 4;\r\n    if (absLat > 60) return 5;\r\n    return 6;\r\n  }\r\n\r\n  /**\r\n   * Convert lat/lon to tile coordinates\r\n   * @param {number} lat - Latitude\r\n   * @param {number} lon - Longitude\r\n   * @param {number} zoom - Zoom level\r\n   * @returns {Array<number>} [x, y] tile coordinates\r\n   */\r\n  latLonToTile(lat, lon, zoom) {\r\n    const n = Math.pow(2, zoom);\r\n    const x = Math.floor((lon + 180) / 360 * n);\r\n    const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + \r\n      1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);\r\n    return [x, y];\r\n  }\r\n\r\n  /**\r\n   * Build URL for a specific tile\r\n   * @param {string} layer - GIBS layer identifier\r\n   * @param {string} date - ISO date string\r\n   * @param {number} zoom - Zoom level\r\n   * @param {number} x - Tile x coordinate\r\n   * @param {number} y - Tile y coordinate\r\n   * @returns {string} Tile URL\r\n   */\r\n  buildTileUrl(layer, date, zoom, x, y) {\r\n    return `${this.wmtsBase}/${layer}/default/${date}/epsg4326/${zoom}/${y}/${x}.jpg`;\r\n  }\r\n\r\n  /**\r\n   * Get resolution in meters for zoom level\r\n   * @param {number} zoom - Zoom level\r\n   * @returns {number} Resolution in meters\r\n   */\r\n  getResolutionForZoom(zoom) {\r\n    const baseResolution = 156543.03392; // meters/pixel at zoom 0\r\n    return baseResolution / Math.pow(2, zoom);\r\n  }\r\n\r\n  /**\r\n   * Construct a WMTS tile URL for a given layer and tile indices (EPSG:4326)\r\n   * @param {object} opts\r\n   * @param {string} opts.layer\r\n   * @param {number|string} opts.tileMatrix\r\n   * @param {number|string} opts.tileRow\r\n   * @param {number|string} opts.tileCol\r\n   * @param {string} [format='image/png']\r\n   * @returns {string} tile URL\r\n   */\r\n  getTileUrl({ layer, tileMatrix, tileRow, tileCol, format = 'image/png' }) {\r\n    // Example WMTS url pattern: /wmts/epsg4326/best/{Layer}/default/{TileMatrix}/{TileRow}/{TileCol}.{format}\r\n    // Use URL-encoded layer name and format extension\r\n    const ext = format.includes('png') ? 'png' : format.includes('jpg') || format.includes('jpeg') ? 'jpg' : 'png';\r\n    const encodedLayer = encodeURIComponent(layer);\r\n    return `${this.wmtsBase}/${encodedLayer}/default/${tileMatrix}/${tileRow}/${tileCol}.${ext}`;\r\n  }\r\n\r\n  /**\r\n   * Ping a specific tile using HEAD to check availability\r\n   * @param {object} opts same as getTileUrl\r\n   * @returns {Promise<{ok:boolean,status:number|string,url:string}>}\r\n   */\r\n  async pingTile(opts) {\r\n    const url = this.getTileUrl(opts);\r\n    try {\r\n      const response = await fetch(url, { \r\n        method: 'HEAD',\r\n        signal: AbortSignal.timeout(8000)\r\n      });\r\n      return { \r\n        ok: response.ok, \r\n        status: response.status, \r\n        url \r\n      };\r\n    } catch (err) {\r\n      return { \r\n        ok: false, \r\n        status: err.message || 'error', \r\n        url \r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nexport default new GIBSService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}