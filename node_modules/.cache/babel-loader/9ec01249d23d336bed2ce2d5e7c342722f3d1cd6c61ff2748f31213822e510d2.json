{"ast":null,"code":"import BaseApiService from './baseApiService.js';\n\n/**\n * Meteomatics Weather API Service\n * Handles professional weather data integration\n */\nclass MeteomaticsService extends BaseApiService {\n  constructor() {\n    super();\n    this.baseUrl = 'https://api.meteomatics.com';\n    this.username = 'narvasa_darryljohn';\n    this.password = '20XN1825ylysfXl8jSXx';\n    this.auth = btoa(`${this.username}:${this.password}`);\n\n    // Set default headers for all requests\n    this.defaultHeaders = {\n      ...this.defaultHeaders,\n      'Authorization': `Basic ${this.auth}`,\n      'Accept': 'application/json'\n    };\n  }\n\n  /**\n   * Fetch historical weather data from Meteomatics API\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {string} targetDate - Target date for analysis\n   * @returns {Promise} Weather data or fallback simulation\n   */\n  async fetchWeatherData(lat, lon, targetDate) {\n    try {\n      // Format the date correctly for the API\n      const formattedDate = new Date(targetDate).toISOString().split('.')[0] + 'Z';\n\n      // Define the weather parameters we want to retrieve\n      const parameters = ['t_2m:C',\n      // Temperature at 2m in Celsius\n      'precip_1h:mm',\n      // Precipitation in mm/hour\n      'wind_speed_10m:ms',\n      // Wind speed at 10m in m/s\n      'relative_humidity_2m:p' // Relative humidity at 2m in percent\n      ].join(',');\n\n      // Construct the API endpoint\n      const endpoint = `${formattedDate}/${parameters}/${lat},${lon}/json`;\n      try {\n        const response = await this.get(endpoint);\n        return this.formatWeatherResponse(response);\n      } catch (apiError) {\n        var _apiError$response, _apiError$response2;\n        console.error('Meteomatics API error:', apiError);\n        if (((_apiError$response = apiError.response) === null || _apiError$response === void 0 ? void 0 : _apiError$response.status) === 401) {\n          throw new Error('Authentication failed. Please check your API credentials.');\n        } else if (((_apiError$response2 = apiError.response) === null || _apiError$response2 === void 0 ? void 0 : _apiError$response2.status) === 429) {\n          throw new Error('Rate limit exceeded. Please try again later.');\n        }\n        // If API call fails, fall back to simulation\n        console.warn('Falling back to simulated data');\n        return this.generateEnhancedWeatherData(lat, lon, targetDate);\n      }\n    } catch (error) {\n      console.error('Error fetching weather data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch current weather conditions\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @returns {Promise} Current weather data\n   */\n  async fetchCurrentWeather(lat, lon) {\n    try {\n      // In production, this would make actual API calls\n      // For now, simulate current weather based on location and date\n      const now = new Date();\n      const hour = now.getHours();\n\n      // Simulate more realistic current conditions based on time of day\n      const timeOfDay = hour >= 6 && hour <= 18 ? 'day' : 'night';\n      const seasonIndex = Math.floor(now.getMonth() / 3); // 0: winter, 1: spring, 2: summer, 3: fall\n\n      // Base temperature on season and time of day\n      const baseTemp = this.getSeasonalBaseTemperature(seasonIndex);\n      const tempVariation = timeOfDay === 'day' ? 5 : -2;\n      return {\n        temperature: baseTemp + tempVariation + (Math.random() * 4 - 2),\n        // Add some randomness\n        humidity: 50 + Math.random() * 30,\n        windSpeed: 5 + Math.random() * 10,\n        precipitation: Math.random() > 0.7 ? Math.random() * 5 : 0,\n        timestamp: now.toISOString()\n      };\n    } catch (error) {\n      console.error('Error fetching current weather:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get base temperature for seasonal simulation\n   * @param {number} seasonIndex - 0: winter, 1: spring, 2: summer, 3: fall\n   * @returns {number} Base temperature\n   */\n  getSeasonalBaseTemperature(seasonIndex) {\n    const seasonTemps = {\n      0: 5,\n      // winter\n      1: 15,\n      // spring\n      2: 25,\n      // summer\n      3: 15 // fall\n    };\n    return seasonTemps[seasonIndex] || 15;\n  }\n\n  /**\n   * Generate simulated weather data based on location and date\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {string} date - Date string\n   * @returns {Object} Simulated weather data\n   */\n  generateSimulatedData(lat, lon, date) {\n    const targetDate = new Date(date);\n    const month = targetDate.getMonth();\n    const seasonIndex = Math.floor(month / 3);\n    const baseTemp = this.getSeasonalBaseTemperature(seasonIndex);\n\n    // Adjust temperature based on latitude\n    const latAdjustment = (90 - Math.abs(lat)) / 90; // Higher latitudes are cooler\n    const adjustedTemp = baseTemp * latAdjustment;\n\n    // Generate realistic variations\n    const hourlyData = [];\n    for (let hour = 0; hour < 24; hour++) {\n      // Temperature varies throughout the day\n      const timeOfDay = Math.sin((hour - 6) * Math.PI / 12); // Peak at 2PM\n      const tempVariation = timeOfDay * 5; // ±5°C variation\n\n      // Precipitation is more likely in certain conditions\n      const precipChance = Math.random() * (timeOfDay + 1) * 0.3; // More rain in afternoons\n      const precipitation = precipChance > 0.7 ? Math.random() * 5 : 0;\n      hourlyData.push({\n        time: `${date}T${hour.toString().padStart(2, '0')}:00:00Z`,\n        temperature: adjustedTemp + tempVariation + (Math.random() * 2 - 1),\n        precipitation: precipitation,\n        humidity: 50 + Math.random() * 30,\n        windSpeed: 5 + Math.random() * 10\n      });\n    }\n    return {\n      location: {\n        lat,\n        lon\n      },\n      date: date,\n      hourly: hourlyData,\n      daily: {\n        temperature: {\n          min: Math.min(...hourlyData.map(h => h.temperature)),\n          max: Math.max(...hourlyData.map(h => h.temperature)),\n          avg: hourlyData.reduce((sum, h) => sum + h.temperature, 0) / 24\n        },\n        precipitation: hourlyData.reduce((sum, h) => sum + h.precipitation, 0),\n        humidity: hourlyData.reduce((sum, h) => sum + h.humidity, 0) / 24,\n        windSpeed: hourlyData.reduce((sum, h) => sum + h.windSpeed, 0) / 24\n      }\n    };\n  }\n\n  /**\n   * Format the API response into a consistent structure\n   * @param {Object} response - Raw API response\n   * @returns {Object} Formatted weather data\n   */\n  formatWeatherResponse(response) {\n    try {\n      if (!response.data || !Array.isArray(response.data)) {\n        throw new Error('Invalid API response format');\n      }\n      const formattedData = {\n        temperature: null,\n        precipitation: null,\n        windSpeed: null,\n        humidity: null,\n        timestamp: new Date().toISOString()\n      };\n      response.data.forEach(param => {\n        if (!param.coordinates || !param.coordinates[0] || !param.coordinates[0].dates) {\n          return;\n        }\n        const value = param.coordinates[0].dates[0].value;\n        switch (param.parameter) {\n          case 't_2m:C':\n            formattedData.temperature = value;\n            break;\n          case 'precip_1h:mm':\n            formattedData.precipitation = value;\n            break;\n          case 'wind_speed_10m:ms':\n            formattedData.windSpeed = value;\n            break;\n          case 'relative_humidity_2m:p':\n            formattedData.humidity = value;\n            break;\n        }\n      });\n\n      // Check if we got all the data we need\n      if (Object.values(formattedData).some(v => v === null)) {\n        throw new Error('Incomplete weather data received');\n      }\n      return formattedData;\n    } catch (error) {\n      console.error('Error formatting weather response:', error);\n      throw new Error('Failed to process weather data');\n    }\n  }\n\n  /**\n   * Generate enhanced weather simulation based on location and climate patterns\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {string} targetDate - Target date\n   * @returns {Object} Enhanced weather data simulation\n   */\n  generateEnhancedWeatherData(lat, lon, targetDate) {\n    if (!this.isValidCoordinates(lat, lon)) {\n      throw new Error('Invalid coordinates provided');\n    }\n\n    // Enhanced simulation with location-based climate patterns\n    const isPhilippines = lat >= 4.5 && lat <= 21.5 && lon >= 116 && lon <= 127;\n    const isTropical = Math.abs(lat) < 23.5;\n    const isNorthernHemisphere = lat > 0;\n    const targetMonth = new Date(targetDate).getMonth() + 1;\n    const targetDay = new Date(targetDate).getDate();\n\n    // Generate realistic daily records based on location\n    const dailyRecords = this.generateDailyRecords(lat, lon, targetMonth, targetDay, isPhilippines, isNorthernHemisphere);\n\n    // Generate monthly data with location intelligence\n    const monthlyData = this.generateMonthlyData(lat, lon, isPhilippines);\n    return {\n      daily: dailyRecords,\n      monthly: monthlyData,\n      metadata: {\n        location: {\n          lat,\n          lon\n        },\n        isPhilippines,\n        isTropical,\n        targetDate,\n        generatedAt: new Date().toISOString()\n      }\n    };\n  }\n\n  /**\n   * Generate daily weather records\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {number} targetMonth - Target month\n   * @param {number} targetDay - Target day\n   * @param {boolean} isPhilippines - Is location in Philippines\n   * @param {boolean} isNorthernHemisphere - Is in northern hemisphere\n   * @returns {Array} Daily weather records\n   */\n  generateDailyRecords(lat, lon, targetMonth, targetDay, isPhilippines, isNorthernHemisphere) {\n    const dailyRecords = [];\n    const currentYear = new Date().getFullYear();\n    for (let year = currentYear - 15; year < currentYear; year++) {\n      const baseTemp = this.getLocationBasedTemperature(lat, lon, targetMonth);\n      const seasonalVariation = Math.sin((targetMonth - 1) * Math.PI / 6) * (isNorthernHemisphere ? 1 : -1);\n      const record = {\n        year,\n        date: `${year}-${targetMonth.toString().padStart(2, '0')}-${targetDay.toString().padStart(2, '0')}`,\n        temperature: Math.round((baseTemp + seasonalVariation + (Math.random() - 0.5) * 8) * 10) / 10,\n        temperatureMax: Math.round((baseTemp + seasonalVariation + 5 + Math.random() * 5) * 10) / 10,\n        temperatureMin: Math.round((baseTemp + seasonalVariation - 5 - Math.random() * 3) * 10) / 10,\n        precipitation: this.getLocationBasedPrecipitation(lat, lon, targetMonth),\n        windSpeed: Math.round((5 + Math.random() * 15) * 10) / 10,\n        humidity: Math.round((60 + Math.random() * 30) * 10) / 10\n      };\n      dailyRecords.push(record);\n    }\n    return dailyRecords;\n  }\n\n  /**\n   * Generate monthly weather data\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {boolean} isPhilippines - Is location in Philippines\n   * @returns {Array} Monthly weather data\n   */\n  generateMonthlyData(lat, lon, isPhilippines) {\n    const monthlyData = [];\n    for (let month = 1; month <= 12; month++) {\n      const monthName = new Date(2000, month - 1, 1).toLocaleString('default', {\n        month: 'short'\n      });\n      const baseTemp = this.getLocationBasedTemperature(lat, lon, month);\n      const basePrecip = this.getLocationBasedPrecipitation(lat, lon, month);\n      monthlyData.push({\n        month: monthName,\n        temperature: Math.round(baseTemp * 10) / 10,\n        rainfall: Math.round(basePrecip * 10) / 10,\n        windSpeed: Math.round((8 + Math.random() * 6) * 10) / 10\n      });\n    }\n    return monthlyData;\n  }\n\n  /**\n   * Get location-based temperature patterns\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {number} month - Month (1-12)\n   * @returns {number} Base temperature for location and month\n   */\n  getLocationBasedTemperature(lat, lon, month) {\n    // Philippines-specific temperature patterns\n    if (lat >= 4.5 && lat <= 21.5 && lon >= 116 && lon <= 127) {\n      const baseTemp = 27; // Philippines average\n      const seasonalVariation = Math.sin((month - 1) * Math.PI / 6) * 2; // Mild seasonal variation\n      return baseTemp + seasonalVariation;\n    }\n\n    // General latitude-based temperature\n    const latitudeFactor = Math.cos(lat * Math.PI / 180);\n    const baseTemp = 15 + latitudeFactor * 20;\n    const seasonalVariation = Math.sin((month - 1) * Math.PI / 6) * (lat > 0 ? 1 : -1) * 15;\n    return baseTemp + seasonalVariation;\n  }\n\n  /**\n   * Get location-based precipitation patterns\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {number} month - Month (1-12)\n   * @returns {number} Precipitation amount for location and month\n   */\n  getLocationBasedPrecipitation(lat, lon, month) {\n    // Philippines monsoon patterns\n    if (lat >= 4.5 && lat <= 21.5 && lon >= 116 && lon <= 127) {\n      // Wet season (June-November), Dry season (December-May)\n      const isWetSeason = month >= 6 && month <= 11;\n      return isWetSeason ? 15 + Math.random() * 25 : 2 + Math.random() * 8;\n    }\n\n    // General precipitation patterns\n    const tropicalFactor = Math.max(0, 1 - Math.abs(lat) / 30);\n    const basePrecip = 5 + tropicalFactor * 15;\n    const seasonalVariation = Math.sin((month - 1) * Math.PI / 6) * 10;\n    return Math.max(0, basePrecip + seasonalVariation + Math.random() * 10);\n  }\n\n  /**\n   * Validate Meteomatics API credentials\n   * @returns {boolean} True if credentials are valid\n   */\n  validateCredentials() {\n    return !!(this.username && this.password && this.auth);\n  }\n\n  /**\n   * Get API status information\n   * @returns {Object} API status and configuration\n   */\n  getApiStatus() {\n    return {\n      service: 'Meteomatics Weather API',\n      hasCredentials: this.validateCredentials(),\n      username: this.username,\n      baseUrl: this.baseUrl,\n      corsBlocked: true,\n      // Direct browser access blocked\n      recommendation: 'Use backend proxy for production'\n    };\n  }\n}\nexport default MeteomaticsService;","map":{"version":3,"names":["BaseApiService","MeteomaticsService","constructor","baseUrl","username","password","auth","btoa","defaultHeaders","fetchWeatherData","lat","lon","targetDate","formattedDate","Date","toISOString","split","parameters","join","endpoint","response","get","formatWeatherResponse","apiError","_apiError$response","_apiError$response2","console","error","status","Error","warn","generateEnhancedWeatherData","fetchCurrentWeather","now","hour","getHours","timeOfDay","seasonIndex","Math","floor","getMonth","baseTemp","getSeasonalBaseTemperature","tempVariation","temperature","random","humidity","windSpeed","precipitation","timestamp","seasonTemps","generateSimulatedData","date","month","latAdjustment","abs","adjustedTemp","hourlyData","sin","PI","precipChance","push","time","toString","padStart","location","hourly","daily","min","map","h","max","avg","reduce","sum","data","Array","isArray","formattedData","forEach","param","coordinates","dates","value","parameter","Object","values","some","v","isValidCoordinates","isPhilippines","isTropical","isNorthernHemisphere","targetMonth","targetDay","getDate","dailyRecords","generateDailyRecords","monthlyData","generateMonthlyData","monthly","metadata","generatedAt","currentYear","getFullYear","year","getLocationBasedTemperature","seasonalVariation","record","round","temperatureMax","temperatureMin","getLocationBasedPrecipitation","monthName","toLocaleString","basePrecip","rainfall","latitudeFactor","cos","isWetSeason","tropicalFactor","validateCredentials","getApiStatus","service","hasCredentials","corsBlocked","recommendation"],"sources":["C:/xampp/htdocs/errors/src/services/api/meteomaticsService.js"],"sourcesContent":["import BaseApiService from './baseApiService.js';\n\n/**\n * Meteomatics Weather API Service\n * Handles professional weather data integration\n */\nclass MeteomaticsService extends BaseApiService {\n  constructor() {\n    super();\n    this.baseUrl = 'https://api.meteomatics.com';\n    this.username = 'narvasa_darryljohn';\n    this.password = '20XN1825ylysfXl8jSXx';\n    this.auth = btoa(`${this.username}:${this.password}`);\n    \n    // Set default headers for all requests\n    this.defaultHeaders = {\n      ...this.defaultHeaders,\n      'Authorization': `Basic ${this.auth}`,\n      'Accept': 'application/json'\n    };\n  }\n\n  /**\n   * Fetch historical weather data from Meteomatics API\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {string} targetDate - Target date for analysis\n   * @returns {Promise} Weather data or fallback simulation\n   */\n  async fetchWeatherData(lat, lon, targetDate) {\n    try {\n      // Format the date correctly for the API\n      const formattedDate = new Date(targetDate).toISOString().split('.')[0] + 'Z';\n      \n      // Define the weather parameters we want to retrieve\n      const parameters = [\n        't_2m:C',        // Temperature at 2m in Celsius\n        'precip_1h:mm',  // Precipitation in mm/hour\n        'wind_speed_10m:ms', // Wind speed at 10m in m/s\n        'relative_humidity_2m:p' // Relative humidity at 2m in percent\n      ].join(',');\n\n      // Construct the API endpoint\n      const endpoint = `${formattedDate}/${parameters}/${lat},${lon}/json`;\n      \n      try {\n        const response = await this.get(endpoint);\n        return this.formatWeatherResponse(response);\n      } catch (apiError) {\n        console.error('Meteomatics API error:', apiError);\n        if (apiError.response?.status === 401) {\n          throw new Error('Authentication failed. Please check your API credentials.');\n        } else if (apiError.response?.status === 429) {\n          throw new Error('Rate limit exceeded. Please try again later.');\n        }\n        // If API call fails, fall back to simulation\n        console.warn('Falling back to simulated data');\n        return this.generateEnhancedWeatherData(lat, lon, targetDate);\n      }\n    } catch (error) {\n      console.error('Error fetching weather data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch current weather conditions\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @returns {Promise} Current weather data\n   */\n  async fetchCurrentWeather(lat, lon) {\n    try {\n      // In production, this would make actual API calls\n      // For now, simulate current weather based on location and date\n      const now = new Date();\n      const hour = now.getHours();\n      \n      // Simulate more realistic current conditions based on time of day\n      const timeOfDay = hour >= 6 && hour <= 18 ? 'day' : 'night';\n      const seasonIndex = Math.floor(now.getMonth() / 3); // 0: winter, 1: spring, 2: summer, 3: fall\n      \n      // Base temperature on season and time of day\n      const baseTemp = this.getSeasonalBaseTemperature(seasonIndex);\n      const tempVariation = timeOfDay === 'day' ? 5 : -2;\n      \n      return {\n        temperature: baseTemp + tempVariation + (Math.random() * 4 - 2), // Add some randomness\n        humidity: 50 + (Math.random() * 30),\n        windSpeed: 5 + (Math.random() * 10),\n        precipitation: Math.random() > 0.7 ? Math.random() * 5 : 0,\n        timestamp: now.toISOString()\n      };\n    } catch (error) {\n      console.error('Error fetching current weather:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get base temperature for seasonal simulation\n   * @param {number} seasonIndex - 0: winter, 1: spring, 2: summer, 3: fall\n   * @returns {number} Base temperature\n   */\n  getSeasonalBaseTemperature(seasonIndex) {\n    const seasonTemps = {\n      0: 5,  // winter\n      1: 15, // spring\n      2: 25, // summer\n      3: 15  // fall\n    };\n    return seasonTemps[seasonIndex] || 15;\n  }\n\n  /**\n   * Generate simulated weather data based on location and date\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {string} date - Date string\n   * @returns {Object} Simulated weather data\n   */\n  generateSimulatedData(lat, lon, date) {\n    const targetDate = new Date(date);\n    const month = targetDate.getMonth();\n    const seasonIndex = Math.floor(month / 3);\n    const baseTemp = this.getSeasonalBaseTemperature(seasonIndex);\n\n    // Adjust temperature based on latitude\n    const latAdjustment = (90 - Math.abs(lat)) / 90; // Higher latitudes are cooler\n    const adjustedTemp = baseTemp * latAdjustment;\n\n    // Generate realistic variations\n    const hourlyData = [];\n    for (let hour = 0; hour < 24; hour++) {\n      // Temperature varies throughout the day\n      const timeOfDay = Math.sin((hour - 6) * Math.PI / 12); // Peak at 2PM\n      const tempVariation = timeOfDay * 5; // ±5°C variation\n\n      // Precipitation is more likely in certain conditions\n      const precipChance = Math.random() * (timeOfDay + 1) * 0.3; // More rain in afternoons\n      const precipitation = precipChance > 0.7 ? Math.random() * 5 : 0;\n\n      hourlyData.push({\n        time: `${date}T${hour.toString().padStart(2, '0')}:00:00Z`,\n        temperature: adjustedTemp + tempVariation + (Math.random() * 2 - 1),\n        precipitation: precipitation,\n        humidity: 50 + (Math.random() * 30),\n        windSpeed: 5 + (Math.random() * 10)\n      });\n    }\n\n    return {\n      location: { lat, lon },\n      date: date,\n      hourly: hourlyData,\n      daily: {\n        temperature: {\n          min: Math.min(...hourlyData.map(h => h.temperature)),\n          max: Math.max(...hourlyData.map(h => h.temperature)),\n          avg: hourlyData.reduce((sum, h) => sum + h.temperature, 0) / 24\n        },\n        precipitation: hourlyData.reduce((sum, h) => sum + h.precipitation, 0),\n        humidity: hourlyData.reduce((sum, h) => sum + h.humidity, 0) / 24,\n        windSpeed: hourlyData.reduce((sum, h) => sum + h.windSpeed, 0) / 24\n      }\n    };\n  }\n\n  /**\n   * Format the API response into a consistent structure\n   * @param {Object} response - Raw API response\n   * @returns {Object} Formatted weather data\n   */\n  formatWeatherResponse(response) {\n    try {\n      if (!response.data || !Array.isArray(response.data)) {\n        throw new Error('Invalid API response format');\n      }\n\n      const formattedData = {\n        temperature: null,\n        precipitation: null,\n        windSpeed: null,\n        humidity: null,\n        timestamp: new Date().toISOString()\n      };\n\n      response.data.forEach(param => {\n        if (!param.coordinates || !param.coordinates[0] || !param.coordinates[0].dates) {\n          return;\n        }\n\n        const value = param.coordinates[0].dates[0].value;\n        switch (param.parameter) {\n          case 't_2m:C':\n            formattedData.temperature = value;\n            break;\n          case 'precip_1h:mm':\n            formattedData.precipitation = value;\n            break;\n          case 'wind_speed_10m:ms':\n            formattedData.windSpeed = value;\n            break;\n          case 'relative_humidity_2m:p':\n            formattedData.humidity = value;\n            break;\n        }\n      });\n\n      // Check if we got all the data we need\n      if (Object.values(formattedData).some(v => v === null)) {\n        throw new Error('Incomplete weather data received');\n      }\n\n      return formattedData;\n    } catch (error) {\n      console.error('Error formatting weather response:', error);\n      throw new Error('Failed to process weather data');\n    }\n  }\n\n  /**\n   * Generate enhanced weather simulation based on location and climate patterns\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {string} targetDate - Target date\n   * @returns {Object} Enhanced weather data simulation\n   */\n  generateEnhancedWeatherData(lat, lon, targetDate) {\n    if (!this.isValidCoordinates(lat, lon)) {\n      throw new Error('Invalid coordinates provided');\n    }\n\n    // Enhanced simulation with location-based climate patterns\n    const isPhilippines = (lat >= 4.5 && lat <= 21.5 && lon >= 116 && lon <= 127);\n    const isTropical = Math.abs(lat) < 23.5;\n    const isNorthernHemisphere = lat > 0;\n    \n    const targetMonth = new Date(targetDate).getMonth() + 1;\n    const targetDay = new Date(targetDate).getDate();\n    \n    // Generate realistic daily records based on location\n    const dailyRecords = this.generateDailyRecords(lat, lon, targetMonth, targetDay, isPhilippines, isNorthernHemisphere);\n    \n    // Generate monthly data with location intelligence\n    const monthlyData = this.generateMonthlyData(lat, lon, isPhilippines);\n\n    return {\n      daily: dailyRecords,\n      monthly: monthlyData,\n      metadata: {\n        location: { lat, lon },\n        isPhilippines,\n        isTropical,\n        targetDate,\n        generatedAt: new Date().toISOString()\n      }\n    };\n  }\n\n  /**\n   * Generate daily weather records\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {number} targetMonth - Target month\n   * @param {number} targetDay - Target day\n   * @param {boolean} isPhilippines - Is location in Philippines\n   * @param {boolean} isNorthernHemisphere - Is in northern hemisphere\n   * @returns {Array} Daily weather records\n   */\n  generateDailyRecords(lat, lon, targetMonth, targetDay, isPhilippines, isNorthernHemisphere) {\n    const dailyRecords = [];\n    const currentYear = new Date().getFullYear();\n    \n    for (let year = currentYear - 15; year < currentYear; year++) {\n      const baseTemp = this.getLocationBasedTemperature(lat, lon, targetMonth);\n      const seasonalVariation = Math.sin((targetMonth - 1) * Math.PI / 6) * (isNorthernHemisphere ? 1 : -1);\n      \n      const record = {\n        year,\n        date: `${year}-${targetMonth.toString().padStart(2, '0')}-${targetDay.toString().padStart(2, '0')}`,\n        temperature: Math.round((baseTemp + seasonalVariation + (Math.random() - 0.5) * 8) * 10) / 10,\n        temperatureMax: Math.round((baseTemp + seasonalVariation + 5 + Math.random() * 5) * 10) / 10,\n        temperatureMin: Math.round((baseTemp + seasonalVariation - 5 - Math.random() * 3) * 10) / 10,\n        precipitation: this.getLocationBasedPrecipitation(lat, lon, targetMonth),\n        windSpeed: Math.round((5 + Math.random() * 15) * 10) / 10,\n        humidity: Math.round((60 + Math.random() * 30) * 10) / 10\n      };\n      \n      dailyRecords.push(record);\n    }\n    \n    return dailyRecords;\n  }\n\n  /**\n   * Generate monthly weather data\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {boolean} isPhilippines - Is location in Philippines\n   * @returns {Array} Monthly weather data\n   */\n  generateMonthlyData(lat, lon, isPhilippines) {\n    const monthlyData = [];\n    \n    for (let month = 1; month <= 12; month++) {\n      const monthName = new Date(2000, month - 1, 1).toLocaleString('default', { month: 'short' });\n      const baseTemp = this.getLocationBasedTemperature(lat, lon, month);\n      const basePrecip = this.getLocationBasedPrecipitation(lat, lon, month);\n      \n      monthlyData.push({\n        month: monthName,\n        temperature: Math.round(baseTemp * 10) / 10,\n        rainfall: Math.round(basePrecip * 10) / 10,\n        windSpeed: Math.round((8 + Math.random() * 6) * 10) / 10\n      });\n    }\n    \n    return monthlyData;\n  }\n\n  /**\n   * Get location-based temperature patterns\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {number} month - Month (1-12)\n   * @returns {number} Base temperature for location and month\n   */\n  getLocationBasedTemperature(lat, lon, month) {\n    // Philippines-specific temperature patterns\n    if (lat >= 4.5 && lat <= 21.5 && lon >= 116 && lon <= 127) {\n      const baseTemp = 27; // Philippines average\n      const seasonalVariation = Math.sin((month - 1) * Math.PI / 6) * 2; // Mild seasonal variation\n      return baseTemp + seasonalVariation;\n    }\n    \n    // General latitude-based temperature\n    const latitudeFactor = Math.cos(lat * Math.PI / 180);\n    const baseTemp = 15 + latitudeFactor * 20;\n    const seasonalVariation = Math.sin((month - 1) * Math.PI / 6) * (lat > 0 ? 1 : -1) * 15;\n    \n    return baseTemp + seasonalVariation;\n  }\n\n  /**\n   * Get location-based precipitation patterns\n   * @param {number} lat - Latitude\n   * @param {number} lon - Longitude\n   * @param {number} month - Month (1-12)\n   * @returns {number} Precipitation amount for location and month\n   */\n  getLocationBasedPrecipitation(lat, lon, month) {\n    // Philippines monsoon patterns\n    if (lat >= 4.5 && lat <= 21.5 && lon >= 116 && lon <= 127) {\n      // Wet season (June-November), Dry season (December-May)\n      const isWetSeason = month >= 6 && month <= 11;\n      return isWetSeason ? 15 + Math.random() * 25 : 2 + Math.random() * 8;\n    }\n    \n    // General precipitation patterns\n    const tropicalFactor = Math.max(0, 1 - Math.abs(lat) / 30);\n    const basePrecip = 5 + tropicalFactor * 15;\n    const seasonalVariation = Math.sin((month - 1) * Math.PI / 6) * 10;\n    \n    return Math.max(0, basePrecip + seasonalVariation + Math.random() * 10);\n  }\n\n  /**\n   * Validate Meteomatics API credentials\n   * @returns {boolean} True if credentials are valid\n   */\n  validateCredentials() {\n    return !!(this.username && this.password && this.auth);\n  }\n\n  /**\n   * Get API status information\n   * @returns {Object} API status and configuration\n   */\n  getApiStatus() {\n    return {\n      service: 'Meteomatics Weather API',\n      hasCredentials: this.validateCredentials(),\n      username: this.username,\n      baseUrl: this.baseUrl,\n      corsBlocked: true, // Direct browser access blocked\n      recommendation: 'Use backend proxy for production'\n    };\n  }\n}\n\nexport default MeteomaticsService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}